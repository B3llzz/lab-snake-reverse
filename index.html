<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Reversed Snake - Mobile</title>
<style>
  body { 
    margin: 0; 
    background: #050505; 
    display: flex; 
    flex-direction: column;
    justify-content: center; 
    align-items: center; 
    height: 100vh; 
    color: #fff;
    font-family: monospace;
    overflow: hidden; 
    touch-action: none; /* Prevent browser zooming/scrolling */
  }

  #game-wrapper {
    position: relative;
    display: flex;
    justify-content: center;
    align-items: center;
    width: 100%;
    height: 100%;
  }

  canvas { 
    background: #111; 
    border: 2px solid #333; 
    box-shadow: 0 0 20px rgba(0, 255, 255, 0.1);
    image-rendering: pixelated; 
    display: block;
  }

  /* --- UI ELEMENTS --- */
  .ui-layer {
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    pointer-events: none; /* Let clicks pass through to game */
  }

  .github-btn {
    position: absolute;
    top: max(10px, env(safe-area-inset-top)); /* Notch support */
    right: 10px;
    display: flex;
    align-items: center;
    background: rgba(36, 41, 46, 0.8);
    color: white;
    text-decoration: none;
    padding: 6px 12px;
    border-radius: 20px;
    font-size: 12px;
    font-weight: bold;
    border: 1px solid #444;
    pointer-events: auto;
    backdrop-filter: blur(4px);
  }
  .github-icon { width: 16px; height: 16px; fill: white; margin-right: 6px; }
  
  /* --- VIRTUAL JOYSTICK --- */
  #joystick-zone {
    display: none; /* Hidden on desktop */
    position: absolute;
    bottom: 40px;
    left: 50%;
    transform: translateX(-50%);
    width: 140px;
    height: 140px;
    z-index: 100;
  }
  
  .joystick-base {
    position: absolute;
    width: 100%;
    height: 100%;
    background: rgba(255, 255, 255, 0.1);
    border: 2px solid rgba(255, 255, 255, 0.2);
    border-radius: 50%;
    pointer-events: auto; /* Catch touches */
  }

  .joystick-stick {
    position: absolute;
    top: 50%; left: 50%;
    width: 50px;
    height: 50px;
    margin-top: -25px;
    margin-left: -25px;
    background: rgba(0, 255, 255, 0.5);
    border-radius: 50%;
    box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
    transition: transform 0.1s;
    pointer-events: none;
  }
</style>
</head>
<body>

<div id="game-wrapper">
  <canvas id="c"></canvas>

  <div class="ui-layer">
    <a href="#" target="_blank" id="gh-link" class="github-btn">
      <svg class="github-icon" viewBox="0 0 16 16">
        <path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path>
      </svg>
      <span>GitHub</span>
      <span id="star-count" style="margin-left:5px"></span>
    </a>
  </div>

  <div id="joystick-zone">
    <div class="joystick-base"></div>
    <div class="joystick-stick" id="stick"></div>
  </div>
</div>

<script>
// --- CONFIGURATION ---
const GITHUB_REPO = "ImBIOS/lab-snake-reverse"; 
document.getElementById('gh-link').href = `https://github.com/${GITHUB_REPO}`;

// Fetch stars
fetch(`https://api.github.com/repos/${GITHUB_REPO}`)
  .then(res => res.json())
  .then(data => { if(data.stargazers_count) document.getElementById('star-count').innerText = data.stargazers_count; })
  .catch(() => {});

// --- GAME SETUP ---
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const GRID_SIZE = 30; // 30x30 Grid logic remains constant
let CELL_SIZE = 20;   // Calculated dynamically

// --- RESPONSIVE RESIZING ---
function resizeGame() {
  const maxWidth = window.innerWidth;
  const maxHeight = window.innerHeight;
  
  // Reserve some space for UI/Joystick
  const isMobile = maxWidth < 768;
  const availableHeight = isMobile ? maxHeight * 0.70 : maxHeight * 0.95;
  const availableWidth = maxWidth * 0.95;

  const size = Math.min(availableWidth, availableHeight);
  
  // Ensure size aligns with grid to avoid blurring
  const adjustedSize = Math.floor(size / GRID_SIZE) * GRID_SIZE;
  
  canvas.width = adjustedSize;
  canvas.height = adjustedSize;
  CELL_SIZE = canvas.width / GRID_SIZE;
}

window.addEventListener('resize', resizeGame);
resizeGame(); // Initial call

// --- CLASSES ---
class Point {
  constructor(x, y) { this.x = x; this.y = y; }
  add(p) { return new Point(this.x + p.x, this.y + p.y); }
  equals(p) { return this.x === p.x && this.y === p.y; }
  manhattan(p) { return Math.abs(this.x - p.x) + Math.abs(this.y - p.y); }
}

const DIRECTIONS = [ new Point(0, -1), new Point(1, 0), new Point(0, 1), new Point(-1, 0) ];

class PriorityQueue {
  constructor() { this.elements = []; }
  enqueue(item, priority) {
    this.elements.push({item, priority});
    this.elements.sort((a, b) => a.priority - b.priority);
  }
  dequeue() { return this.elements.shift().item; }
  isEmpty() { return this.elements.length === 0; }
}

function findPath(start, goal, snake) {
  const heuristic = p => p.manhattan(goal);
  const pq = new PriorityQueue();
  const cameFrom = new Map();
  const cost = new Map();
  const startKey = `${start.x},${start.y}`;

  pq.enqueue(start, heuristic(start));
  cameFrom.set(startKey, null);
  cost.set(startKey, 0);

  while (!pq.isEmpty()) {
    const current = pq.dequeue();
    if (current.equals(goal)) {
      const path = [];
      let cur = current;
      while (cur) { path.unshift(cur); cur = cameFrom.get(`${cur.x},${cur.y}`); }
      return path;
    }

    for (const dir of DIRECTIONS) {
      const next = current.add(dir);
      if (next.x < 0 || next.x >= GRID_SIZE || next.y < 0 || next.y >= GRID_SIZE) continue;
      const tail = snake.body[snake.body.length - 1];
      if (snake.body.some(s => s.equals(next)) && !next.equals(tail)) continue;

      const newCost = cost.get(`${current.x},${current.y}`) + 1;
      const key = `${next.x},${next.y}`;
      if (!cost.has(key) || newCost < cost.get(key)) {
        cost.set(key, newCost);
        pq.enqueue(next, newCost + heuristic(next));
        cameFrom.set(key, current);
      }
    }
  }
  return null;
}

class Snake {
  constructor() {
    this.body = [];
    const cx = Math.floor(GRID_SIZE / 2);
    const cy = Math.floor(GRID_SIZE / 2);
    for (let i = 0; i < 12; i++) this.body.push(new Point(cx + i, cy));
    this.growing = false;
  }
  get head() { return this.body[0]; }
  get tail() { return this.body[this.body.length - 1]; }
  grow() { this.growing = true; }
}

// --- STATE ---
const game = {
  snake: null,
  apple: null,
  startTime: 0,
  glitchStart: 0,
  gameOver: false,
  survived: 0,
  highScore: 0,
  snakeSpeed: 140,
  appleSpeed: 100,
  lastSnake: 0,
  lastApple: 0,
  growInterval: null
};

// Safe LocalStorage
try { game.highScore = localStorage.getItem('revSnakeHS') || 0; } catch(e) {}

function initApple() {
  let pos;
  do {
    pos = new Point(Math.floor(Math.random() * GRID_SIZE), Math.floor(Math.random() * GRID_SIZE));
  } while (game.snake.body.some(s => s.equals(pos)));
  game.apple = pos;
}

let animFrameId;
let lastTime = 0;

function resetGame() {
  game.snake = new Snake();
  game.gameOver = false;
  game.startTime = Date.now();
  game.survived = 0;
  game.lastSnake = 0;
  game.lastApple = 0;
  if (game.growInterval) clearInterval(game.growInterval);
  initApple();
  game.growInterval = setInterval(() => game.snake.grow(), 5000);
  
  if (animFrameId) cancelAnimationFrame(animFrameId);
  lastTime = 0;
  animFrameId = requestAnimationFrame(loop);
}

// --- INPUTS & JOYSTICK ---
const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };

window.addEventListener('keydown', e => { 
  if(["Space","ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].includes(e.code)) e.preventDefault();
  if ((e.code === 'Space' || e.code === 'Enter') && game.gameOver) resetGame();
  if (e.key in keys) keys[e.key] = true; 
});
window.addEventListener('keyup', e => { if (e.key in keys) keys[e.key] = false; });

// Detect Touch Device
if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
  document.getElementById('joystick-zone').style.display = 'block';
  resizeGame(); // Re-trigger resize to account for visual joystick
}

// Joystick Logic
const joystickZone = document.querySelector('.joystick-base');
const stick = document.getElementById('stick');
let jActive = false;

joystickZone.addEventListener('touchstart', e => {
  e.preventDefault();
  jActive = true;
  handleJoystick(e.changedTouches[0]);
  if (game.gameOver) resetGame();
}, {passive: false});

joystickZone.addEventListener('touchmove', e => {
  if (!jActive) return;
  e.preventDefault();
  handleJoystick(e.changedTouches[0]);
}, {passive: false});

const endJoystick = (e) => {
  jActive = false;
  stick.style.transform = `translate(0px, 0px)`;
  Object.keys(keys).forEach(k => keys[k] = false);
};
joystickZone.addEventListener('touchend', endJoystick);
joystickZone.addEventListener('touchcancel', endJoystick);

function handleJoystick(touch) {
  const rect = joystickZone.getBoundingClientRect();
  const centerX = rect.left + rect.width / 2;
  const centerY = rect.top + rect.height / 2;
  
  const x = touch.clientX - centerX;
  const y = touch.clientY - centerY;
  
  // Visual limit
  const dist = Math.min(35, Math.sqrt(x*x + y*y));
  const angle = Math.atan2(y, x);
  const moveX = Math.cos(angle) * dist;
  const moveY = Math.sin(angle) * dist;
  
  stick.style.transform = `translate(${moveX}px, ${moveY}px)`;

  // Input Mapping (Directional)
  Object.keys(keys).forEach(k => keys[k] = false);
  
  // Deadzone of 10px
  if (dist > 10) {
    if (Math.abs(x) > Math.abs(y)) {
      if (x > 0) keys.ArrowRight = true;
      else keys.ArrowLeft = true;
    } else {
      if (y > 0) keys.ArrowDown = true;
      else keys.ArrowUp = true;
    }
  }
}

function getInputDir() {
  let dx = 0, dy = 0;
  if (keys.ArrowLeft) dx--;
  if (keys.ArrowRight) dx++;
  if (keys.ArrowUp) dy--;
  if (keys.ArrowDown) dy++;
  return (dx || dy) ? new Point(dx, dy) : null;
}

// --- LOGIC ---
function checkClose() {
  const min = Math.min(...game.snake.body.map(s => s.manhattan(game.apple)));
  if (min <= 1) game.glitchStart = Date.now();
}

function gameOverFunc() {
  game.gameOver = true;
  clearInterval(game.growInterval);
  game.survived = (Date.now() - game.startTime) / 1000;
  if (game.survived > game.highScore) {
    game.highScore = game.survived;
    try { localStorage.setItem('revSnakeHS', game.highScore); } catch(e){}
  }
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  const glitching = Date.now() - game.glitchStart < 700;
  if (glitching) {
    ctx.save();
    const amp = CELL_SIZE * 0.5;
    ctx.translate((Math.random() - 0.5) * amp, (Math.random() - 0.5) * amp);
  }

  // Grid BG
  ctx.fillStyle = '#111';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // Faint Grid Lines
  ctx.strokeStyle = '#1a1a1a';
  ctx.lineWidth = 1;
  ctx.beginPath();
  for(let i=0; i<=GRID_SIZE; i++) {
    ctx.moveTo(i*CELL_SIZE, 0); ctx.lineTo(i*CELL_SIZE, canvas.height);
    ctx.moveTo(0, i*CELL_SIZE); ctx.lineTo(canvas.width, i*CELL_SIZE);
  }
  ctx.stroke();

  // Draw Entities
  if (game.snake) {
    game.snake.body.forEach((seg, i) => {
      ctx.fillStyle = i === 0 ? '#0ff' : '#0a0';
      ctx.fillRect(seg.x * CELL_SIZE + 1, seg.y * CELL_SIZE + 1, CELL_SIZE - 2, CELL_SIZE - 2);
    });
  }
  if (game.apple) {
    ctx.fillStyle = '#f33';
    ctx.beginPath();
    ctx.arc((game.apple.x + 0.5) * CELL_SIZE, (game.apple.y + 0.5) * CELL_SIZE, CELL_SIZE * 0.35, 0, Math.PI * 2);
    ctx.fill();
  }

  // Text UI (Scaled)
  const fontSize = Math.max(12, Math.floor(CELL_SIZE * 0.8));
  const time = game.gameOver ? game.survived : (Date.now() - game.startTime) / 1000;
  
  ctx.fillStyle = '#fff';
  ctx.font = `${fontSize}px monospace`;
  ctx.fillText(`Time: ${time.toFixed(1)}s`, 10, fontSize + 5);
  ctx.fillText(`Best: ${Number(game.highScore).toFixed(1)}s`, 10, (fontSize * 2) + 10);

  if (game.gameOver) {
    ctx.save();
    ctx.fillStyle = 'rgba(0,0,0,0.85)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    ctx.shadowColor = "#f00";
    ctx.shadowBlur = 20;
    ctx.fillStyle = '#f00';
    ctx.textAlign = "center";
    
    const bigFont = Math.floor(canvas.width / 10);
    ctx.font = `${bigFont}px monospace`;
    ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2 - 20);
    
    ctx.shadowBlur = 0;
    ctx.fillStyle = '#fff';
    ctx.font = `${fontSize * 1.5}px monospace`;
    ctx.fillText(`You lasted ${time.toFixed(1)}s`, canvas.width/2, canvas.height/2 + bigFont);
    
    ctx.fillStyle = '#aaa';
    ctx.font = `${fontSize}px monospace`;
    ctx.fillText('Tap to Restart', canvas.width/2, canvas.height/2 + bigFont * 1.8);
    ctx.restore();
  }
  
  if (glitching) ctx.restore();
}

function loop(t) {
  animFrameId = requestAnimationFrame(loop);
  if (!lastTime) { lastTime = t; return; }
  const delta = t - lastTime;
  lastTime = t;

  if (!game.gameOver) {
    game.lastSnake += delta;
    game.lastApple += delta;

    if (game.lastSnake >= game.snakeSpeed) {
      const path = findPath(game.snake.head, game.apple, game.snake);
      let nextDir = null;
      if (path && path.length > 1) {
        nextDir = new Point(path[1].x - game.snake.head.x, path[1].y - game.snake.head.y);
      } else {
        if (game.snake.body.length > 8) game.snake.body.pop();
        const candidates = DIRECTIONS.filter(d => {
          const np = game.snake.head.add(d);
          if (np.x < 0 || np.x >= GRID_SIZE || np.y < 0 || np.y >= GRID_SIZE) return false;
          return !game.snake.body.some(s => s.equals(np)) || np.equals(game.snake.tail);
        });
        if (candidates.length) {
          candidates.sort((a, b) => game.apple.manhattan(game.snake.head.add(a)) - game.apple.manhattan(game.snake.head.add(b)));
          nextDir = candidates[0];
        }
      }

      if (nextDir) {
        const newHead = game.snake.head.add(nextDir);
        if (newHead.equals(game.apple)) gameOverFunc();
        else {
          game.snake.body.unshift(newHead);
          if (!game.snake.growing) game.snake.body.pop();
          else game.snake.growing = false;
        }
      }
      game.lastSnake -= game.snakeSpeed;
      checkClose();
    }

    if (game.lastApple >= game.appleSpeed) {
      const dir = getInputDir();
      if (dir) {
        const np = game.apple.add(dir);
        if (np.x >= 0 && np.x < GRID_SIZE && np.y >= 0 && np.y < GRID_SIZE && !game.snake.body.some(s => s.equals(np))) {
          game.apple = np;
          checkClose();
        }
      }
      game.lastApple -= game.appleSpeed;
    }
  }
  draw();
}

resetGame();
</script>
</body>
</html>
