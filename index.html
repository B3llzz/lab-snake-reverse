<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Reversed Snake - You are the Apple</title>
<style>
  body { 
    margin: 0; 
    background: #050505; 
    display: flex; 
    flex-direction: column;
    justify-content: center; 
    align-items: center; 
    height: 100vh; 
    color: #fff;
    font-family: monospace;
    overflow: hidden; 
  }

  #game-container {
    position: relative;
    box-shadow: 0 0 50px rgba(0, 255, 255, 0.1);
  }

  canvas { 
    background: #111; 
    border: 2px solid #333; 
    display: block;
    image-rendering: pixelated; 
    max-width: 100vw;
    max-height: 100vh;
  }

  /* GitHub Button Styling */
  .github-btn {
    position: absolute;
    top: 10px;
    right: 10px;
    display: flex;
    align-items: center;
    background: #24292e;
    color: white;
    text-decoration: none;
    padding: 5px 10px;
    border-radius: 5px;
    font-size: 12px;
    font-weight: bold;
    border: 1px solid #444;
    transition: background 0.2s;
    z-index: 10;
  }
  .github-btn:hover { background: #444; }
  .github-icon { width: 16px; height: 16px; fill: white; margin-right: 6px; }
  .star-count { 
    background: #444; 
    padding: 2px 6px; 
    border-radius: 10px; 
    margin-left: 8px; 
    font-size: 11px; 
  }
</style>
</head>
<body>

<div id="game-container">
  <a href="#" target="_blank" id="gh-link" class="github-btn">
    <svg class="github-icon" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path>
    </svg>
    <span>GitHub</span>
    <span id="star-count" class="star-count">0</span>
  </a>
  
  <canvas id="c" width="600" height="600"></canvas>
</div>

<script>
// --- CONFIGURATION ---
const GITHUB_REPO = "ImBIOS/lab-snake-reverse"; 
const GITHUB_URL = `https://github.com/${GITHUB_REPO}`;
document.getElementById('gh-link').href = GITHUB_URL;

// Fetch stars (Async - won't block game)
fetch(`https://api.github.com/repos/${GITHUB_REPO}`)
  .then(res => res.json())
  .then(data => {
    if(data.stargazers_count !== undefined) {
      document.getElementById('star-count').innerText = data.stargazers_count;
    }
  })
  .catch(e => console.log("Repo info skipped"));

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const GRID_SIZE = 30;
const CELL_SIZE = canvas.width / GRID_SIZE;

class Point {
  constructor(x, y) { this.x = x; this.y = y; }
  add(p) { return new Point(this.x + p.x, this.y + p.y); }
  equals(p) { return this.x === p.x && this.y === p.y; }
  manhattan(p) { return Math.abs(this.x - p.x) + Math.abs(this.y - p.y); }
}

const DIRECTIONS = [
  new Point(0, -1), new Point(1, 0),
  new Point(0, 1), new Point(-1, 0)
];

class PriorityQueue {
  constructor() { this.elements = []; }
  enqueue(item, priority) {
    this.elements.push({item, priority});
    this.elements.sort((a, b) => a.priority - b.priority);
  }
  dequeue() { return this.elements.shift().item; }
  isEmpty() { return this.elements.length === 0; }
}

function findPath(start, goal, snake) {
  const heuristic = p => p.manhattan(goal);
  const pq = new PriorityQueue();
  const cameFrom = new Map();
  const cost = new Map();
  const startKey = `${start.x},${start.y}`;

  pq.enqueue(start, heuristic(start));
  cameFrom.set(startKey, null);
  cost.set(startKey, 0);

  while (!pq.isEmpty()) {
    const current = pq.dequeue();
    if (current.equals(goal)) {
      const path = [];
      let cur = current;
      while (cur) {
        path.unshift(cur);
        cur = cameFrom.get(`${cur.x},${cur.y}`);
      }
      return path;
    }

    for (const dir of DIRECTIONS) {
      const next = current.add(dir);
      if (next.x < 0 || next.x >= GRID_SIZE || next.y < 0 || next.y >= GRID_SIZE) continue;
      const tail = snake.body[snake.body.length - 1];
      if (snake.body.some(s => s.equals(next)) && !next.equals(tail)) continue;

      const newCost = cost.get(`${current.x},${current.y}`) + 1;
      const key = `${next.x},${next.y}`;
      if (!cost.has(key) || newCost < cost.get(key)) {
        cost.set(key, newCost);
        pq.enqueue(next, newCost + heuristic(next));
        cameFrom.set(key, current);
      }
    }
  }
  return null;
}

class Snake {
  constructor() {
    this.body = [];
    const cx = Math.floor(GRID_SIZE / 2);
    const cy = Math.floor(GRID_SIZE / 2);
    for (let i = 0; i < 12; i++) this.body.push(new Point(cx + i, cy));
    this.growing = false;
  }
  get head() { return this.body[0]; }
  get tail() { return this.body[this.body.length - 1]; }
  grow() { this.growing = true; }
}

const game = {
  snake: null,
  apple: null,
  startTime: 0,
  glitchStart: 0,
  gameOver: false,
  survived: 0,
  highScore: 0,
  snakeSpeed: 140,
  appleSpeed: 100,
  lastSnake: 0,
  lastApple: 0,
  growInterval: null
};

// SAFE LOCAL STORAGE LOADING
try {
  game.highScore = localStorage.getItem('reversedSnakeHighScore') || 0;
} catch(e) {
  console.log("Local Storage blocked, high score disabled");
}

function initApple() {
  let pos;
  do {
    pos = new Point(Math.floor(Math.random() * GRID_SIZE), Math.floor(Math.random() * GRID_SIZE));
  } while (game.snake.body.some(s => s.equals(pos)));
  game.apple = pos;
}

let animFrameId = null;
let lastTime = 0;

function resetGame() {
  game.snake = new Snake();
  game.gameOver = false;
  game.startTime = Date.now();
  game.survived = 0;
  game.lastSnake = 0;
  game.lastApple = 0;
  
  if (game.growInterval) clearInterval(game.growInterval);
  initApple();
  game.growInterval = setInterval(() => game.snake.grow(), 5000);

  // Restart Loop safely
  if (animFrameId) cancelAnimationFrame(animFrameId);
  lastTime = 0;
  animFrameId = requestAnimationFrame(loop);
}

// Input Handling
const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };

window.addEventListener('keydown', e => { 
  if(["Space","ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].indexOf(e.code) > -1) {
      e.preventDefault();
  }
  
  if ((e.code === 'Space' || e.code === 'Enter') && game.gameOver) {
    resetGame();
    return;
  }

  if (e.key in keys) keys[e.key] = true; 
});

window.addEventListener('keyup', e => { if (e.key in keys) keys[e.key] = false; });

// --- TOUCH CONTROLS ---
let touchStartX = 0;
let touchStartY = 0;

canvas.addEventListener('touchstart', function(e) {
  touchStartX = e.changedTouches[0].screenX;
  touchStartY = e.changedTouches[0].screenY;
  if (game.gameOver) { resetGame(); }
}, {passive: false});

canvas.addEventListener('touchmove', function(e) {
  e.preventDefault();
  const touchEndX = e.changedTouches[0].screenX;
  const touchEndY = e.changedTouches[0].screenY;
  const dx = touchEndX - touchStartX;
  const dy = touchEndY - touchStartY;
  
  Object.keys(keys).forEach(k => keys[k] = false);
  
  if (Math.abs(dx) > Math.abs(dy)) {
    if (Math.abs(dx) > 10) { 
      if (dx > 0) keys.ArrowRight = true;
      else keys.ArrowLeft = true;
    }
  } else {
    if (Math.abs(dy) > 10) {
      if (dy > 0) keys.ArrowDown = true;
      else keys.ArrowUp = true;
    }
  }
}, {passive: false});

canvas.addEventListener('touchend', function(e) {
  Object.keys(keys).forEach(k => keys[k] = false);
});


function getInputDir() {
  let dx = 0, dy = 0;
  if (keys.ArrowLeft) dx--;
  if (keys.ArrowRight) dx++;
  if (keys.ArrowUp) dy--;
  if (keys.ArrowDown) dy++;
  return (dx || dy) ? new Point(dx, dy) : null;
}

function checkClose() {
  const min = Math.min(...game.snake.body.map(s => s.manhattan(game.apple)));
  if (min <= 1) game.glitchStart = Date.now();
}

function gameOverFunc() {
  game.gameOver = true;
  clearInterval(game.growInterval);
  game.survived = (Date.now() - game.startTime) / 1000;
  
  if (game.survived > game.highScore) {
    game.highScore = game.survived;
    try {
      localStorage.setItem('reversedSnakeHighScore', game.highScore);
    } catch(e) {}
  }
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  const glitching = Date.now() - game.glitchStart < 700;
  if (glitching) {
    ctx.save();
    const amp = 20;
    ctx.translate((Math.random() - 0.5) * amp, (Math.random() - 0.5) * amp);
  }

  // background
  ctx.fillStyle = '#111';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Subtle grid
  ctx.strokeStyle = '#1a1a1a';
  ctx.lineWidth = 1;
  ctx.beginPath();
  for(let i=0; i<=GRID_SIZE; i++) {
    ctx.moveTo(i*CELL_SIZE, 0); ctx.lineTo(i*CELL_SIZE, canvas.height);
    ctx.moveTo(0, i*CELL_SIZE); ctx.lineTo(canvas.width, i*CELL_SIZE);
  }
  ctx.stroke();

  // snake
  if (game.snake) {
    game.snake.body.forEach((seg, i) => {
      ctx.fillStyle = i === 0 ? '#0ff' : '#0a0';
      ctx.fillRect(seg.x * CELL_SIZE + 2, seg.y * CELL_SIZE + 2, CELL_SIZE - 4, CELL_SIZE - 4);
    });
  }

  // apple
  if (game.apple) {
    ctx.fillStyle = '#f33';
    ctx.beginPath();
    ctx.arc((game.apple.x + 0.5) * CELL_SIZE, (game.apple.y + 0.5) * CELL_SIZE, CELL_SIZE * 0.4, 0, Math.PI * 2);
    ctx.fill();
  }

  // UI
  const time = game.gameOver ? game.survived : (Date.now() - game.startTime) / 1000;
  ctx.fillStyle = '#fff';
  ctx.textAlign = 'left'; // Reset alignment
  ctx.font = '20px monospace';
  ctx.fillText(`Time: ${time.toFixed(1)}s`, 10, 30);
  ctx.fillText(`High Score: ${Number(game.highScore).toFixed(1)}s`, 10, 60);
  ctx.fillText(`Length: ${game.snake ? game.snake.body.length : 0}`, 10, 90);

  if (game.gameOver) {
    ctx.save();
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    ctx.shadowColor = "#f00";
    ctx.shadowBlur = 20;
    ctx.font = '60px monospace';
    ctx.fillStyle = '#f00';
    ctx.textAlign = "center";
    ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2 - 20);
    
    ctx.shadowBlur = 0;
    ctx.font = '20px monospace';
    ctx.fillStyle = '#fff';
    ctx.fillText(`You survived ${time.toFixed(1)}s`, canvas.width/2, canvas.height/2 + 30);
    
    ctx.fillStyle = '#aaa';
    ctx.font = '16px monospace';
    ctx.fillText('Press SPACE or Tap to Restart', canvas.width/2, canvas.height/2 + 60);
    ctx.restore();
  }

  if (glitching) ctx.restore();
}

function loop(t) {
  animFrameId = requestAnimationFrame(loop);
  
  if (!lastTime) { lastTime = t; return; }
  const delta = t - lastTime;
  lastTime = t;

  if (!game.gameOver) {
    game.lastSnake += delta;
    game.lastApple += delta;

    // Snake move logic
    if (game.lastSnake >= game.snakeSpeed) {
      const path = findPath(game.snake.head, game.apple, game.snake);
      let nextDir = null;

      if (path && path.length > 1) {
        nextDir = new Point(path[1].x - game.snake.head.x, path[1].y - game.snake.head.y);
      } else {
        // Trapped logic
        if (game.snake.body.length > 8) game.snake.body.pop();

        const candidates = DIRECTIONS.filter(d => {
          const np = game.snake.head.add(d);
          if (np.x < 0 || np.x >= GRID_SIZE || np.y < 0 || np.y >= GRID_SIZE) return false;
          const tail = game.snake.tail;
          return !game.snake.body.some(s => s.equals(np)) || np.equals(tail);
        });
        if (candidates.length) {
          candidates.sort((a, b) => game.apple.manhattan(game.snake.head.add(a)) - game.apple.manhattan(game.snake.head.add(b)));
          nextDir = candidates[0];
        }
      }

      if (nextDir) {
        const newHead = game.snake.head.add(nextDir);
        if (newHead.equals(game.apple)) { gameOverFunc(); }
        else {
          game.snake.body.unshift(newHead);
          if (!game.snake.growing) game.snake.body.pop();
          else game.snake.growing = false;
        }
      }
      game.lastSnake -= game.snakeSpeed;
      checkClose();
    }

    // Apple move logic
    if (game.lastApple >= game.appleSpeed) {
      const dir = getInputDir();
      if (dir) {
        const np = game.apple.add(dir);
        if (np.x >= 0 && np.x < GRID_SIZE && np.y >= 0 && np.y < GRID_SIZE &&
            !game.snake.body.some(s => s.equals(np))) {
          game.apple = np;
          checkClose();
        }
      }
      game.lastApple -= game.appleSpeed;
    }
  }

  draw();
}

// Start Game
resetGame();
</script>
</body>
</html>
