<![CDATA[<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Reversed Snake - You are the Apple</title>
<style>
  body { margin:0; background:#000; display:flex; justify-content:center; align-items:center; height:100vh; }
  canvas { background:#111; box-shadow:0 0 30px #000; image-rendering:pixelated; }
</style>
</head>
<body>
<canvas id="c" width="600" height="600"></canvas>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const GRID_SIZE = 30;
const CELL_SIZE = canvas.width / GRID_SIZE;
class Point {
  constructor(x, y) { this.x = x; this.y = y; }
  add(p) { return new Point(this.x + p.x, this.y + p.y); }
  equals(p) { return this.x === p.x && this.y === p.y; }
  manhattan(p) { return Math.abs(this.x - p.x) + Math.abs(this.y - p.y); }
}
const DIRECTIONS = [
  new Point(0, -1), new Point(1, 0),
  new Point(0, 1), new Point(-1, 0)
];
class PriorityQueue {
  constructor() { this.elements = []; }
  enqueue(item, priority) {
    this.elements.push({item, priority});
    this.elements.sort((a, b) => a.priority - b.priority);
  }
  dequeue() { return this.elements.shift().item; }
  isEmpty() { return this.elements.length === 0; }
}
function findPath(start, goal, snake) {
  const heuristic = p => p.manhattan(goal);
  const pq = new PriorityQueue();
  const cameFrom = new Map();
  const cost = new Map();
  const startKey = `${start.x},${start.y}`;
  pq.enqueue(start, heuristic(start));
  cameFrom.set(startKey, null);
  cost.set(startKey, 0);
  while (!pq.isEmpty()) {
    const current = pq.dequeue();
    if (current.equals(goal)) {
      const path = [];
      let cur = current;
      while (cur) {
        path.unshift(cur);
        cur = cameFrom.get(`${cur.x},${cur.y}`);
      }
      return path;
    }
    for (const dir of DIRECTIONS) {
      const next = current.add(dir);
      if (next.x < 0 || next.x >= GRID_SIZE || next.y < 0 || next.y >= GRID_SIZE) continue;
      const tail = snake.body[snake.body.length - 1];
      if (snake.body.some(s => s.equals(next)) && !next.equals(tail)) continue;
      const newCost = cost.get(`${current.x},${current.y}`) + 1;
      const key = `${next.x},${next.y}`;
      if (!cost.has(key) || newCost < cost.get(key)) {
        cost.set(key, newCost);
        pq.enqueue(next, newCost + heuristic(next));
        cameFrom.set(key, current);
      }
    }
  }
  return null;
}
class Snake {
  constructor() {
    this.body = [];
    const cx = Math.floor(GRID_SIZE / 2);
    const cy = Math.floor(GRID_SIZE / 2);
    for (let i = 0; i < 12; i++) this.body.push(new Point(cx + i, cy));
    this.growing = false;
  }
  get head() { return this.body[0]; }
  get tail() { return this.body[this.body.length - 1]; }
  grow() { this.growing = true; }
}
const game = {
  snake: new Snake(),
  apple: null,
  startTime: Date.now(),
  glitchStart: 0,
  gameOver: false,
  survived: 0,
  snakeSpeed: 140,
  appleSpeed: 100,
  lastSnake: 0,
  lastApple: 0,
  growInterval: null
};
function initApple() {
  let pos;
  do {
    pos = new Point(Math.floor(Math.random() * GRID_SIZE), Math.floor(Math.random() * GRID_SIZE));
  } while (game.snake.body.some(s => s.equals(pos)));
  game.apple = pos;
}
initApple();
game.growInterval = setInterval(() => game.snake.grow(), 5000);
const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };
window.addEventListener('keydown', e => { if (e.key in keys) { keys[e.key] = true; e.preventDefault(); } });
window.addEventListener('keyup', e => { if (e.key in keys) keys[e.key] = false; });
function getInputDir() {
  let dx = 0, dy = 0;
  if (keys.ArrowLeft) dx--;
  if (keys.ArrowRight) dx++;
  if (keys.ArrowUp) dy--;
  if (keys.ArrowDown) dy++;
  return (dx || dy) ? new Point(dx, dy) : null;
}
function checkClose() {
  const min = Math.min(...game.snake.body.map(s => s.manhattan(game.apple)));
  if (min <= 1) game.glitchStart = Date.now();
}
function gameOverFunc() {
  game.gameOver = true;
  clearInterval(game.growInterval);
  game.survived = (Date.now() - game.startTime) / 1000;
}
function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  const glitching = Date.now() - game.glitchStart < 700;
  if (glitching) {
    ctx.save();
    const amp = 20;
    ctx.translate((Math.random() - 0.5) * amp, (Math.random() - 0.5) * amp);
  }
  // background
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  // snake
  game.snake.body.forEach((seg, i) => {
    ctx.fillStyle = i === 0 ? '#0ff' : '#0a0';
    ctx.fillRect(seg.x * CELL_SIZE + 2, seg.y * CELL_SIZE + 2, CELL_SIZE - 4, CELL_SIZE - 4);
  });
  // apple
  ctx.fillStyle = '#f33';
  ctx.beginPath();
  ctx.arc((game.apple.x + 0.5) * CELL_SIZE, (game.apple.y + 0.5) * CELL_SIZE, CELL_SIZE * 0.4, 0, Math.PI * 2);
  ctx.fill();
  // UI
  const time = game.gameOver ? game.survived : (Date.now() - game.startTime) / 1000;
  ctx.fillStyle = '#fff';
  ctx.font = '20px monospace';
  ctx.fillText(`Time: ${time.toFixed(1)}s`, 10, 30);
  ctx.fillText(`Length: ${game.snake.body.length}`, 10, 60);
  if (game.gameOver) {
    ctx.font = '60px monospace';
    ctx.fillStyle = '#f00';
    ctx.fillText('GAME OVER', 80, 300);
    ctx.font = '30px monospace';
    ctx.fillStyle = '#fff';
    ctx.fillText(`Survived ${time.toFixed(1)}s`, 140, 360);
  }
  if (glitching) ctx.restore();
}
let lastTime = 0;
function loop(t) {
  if (!lastTime) lastTime = t;
  const delta = t - lastTime;
  lastTime = t;
  if (!game.gameOver) {
    game.lastSnake += delta;
    game.lastApple += delta;
    // Snake move
    if (game.lastSnake >= game.snakeSpeed) {
      const path = findPath(game.snake.head, game.apple, game.snake);
      let nextDir = null;
      if (path && path.length > 1) {
        nextDir = new Point(path[1].x - game.snake.head.x, path[1].y - game.snake.head.y);
      } else {
        // trapped -> shrink
        if (game.snake.body.length > 8) game.snake.body.pop();
        // greedy closest move
        const candidates = DIRECTIONS.filter(d => {
          const np = game.snake.head.add(d);
          if (np.x < 0 || np.x >= GRID_SIZE || np.y < 0 || np.y >= GRID_SIZE) return false;
          const tail = game.snake.tail;
          return !game.snake.body.some(s => s.equals(np)) || np.equals(tail);
        });
        if (candidates.length) {
          candidates.sort((a, b) => game.apple.manhattan(game.snake.head.add(a)) - game.apple.manhattan(game.snake.head.add(b)));
          nextDir = candidates[0];
        }
      }
      if (nextDir) {
        const newHead = game.snake.head.add(nextDir);
        if (newHead.equals(game.apple)) { gameOverFunc(); }
        else {
          game.snake.body.unshift(newHead);
          if (!game.snake.growing) game.snake.body.pop();
          else game.snake.growing = false;
        }
      }
      game.lastSnake -= game.snakeSpeed;
      checkClose();
    }
    // Apple move
    if (game.lastApple >= game.appleSpeed) {
      const dir = getInputDir();
      if (dir) {
        const np = game.apple.add(dir);
        if (np.x >= 0 && np.x < GRID_SIZE && np.y >= 0 && np.y < GRID_SIZE &&
            !game.snake.body.some(s => s.equals(np))) {
          game.apple = np;
          checkClose();
        }
      }
      game.lastApple -= game.appleSpeed;
    }
  }
  draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>]]>
